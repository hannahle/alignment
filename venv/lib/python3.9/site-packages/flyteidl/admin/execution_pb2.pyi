"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import flyteidl.admin.common_pb2
import flyteidl.core.execution_pb2
import flyteidl.core.identifier_pb2
import flyteidl.core.literals_pb2
import flyteidl.core.security_pb2
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class ExecutionCreateRequest(google.protobuf.message.Message):
    """Request to launch an execution with the given project, domain and optionally-assigned name."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    PROJECT_FIELD_NUMBER: builtins.int
    DOMAIN_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SPEC_FIELD_NUMBER: builtins.int
    INPUTS_FIELD_NUMBER: builtins.int
    project: typing.Text = ...
    """Name of the project the execution belongs to.
    +required
    """

    domain: typing.Text = ...
    """Name of the domain the execution belongs to.
    A domain can be considered as a subset within a specific project.
    +required
    """

    name: typing.Text = ...
    """User provided value for the resource.
    If none is provided the system will generate a unique string.
    +optional
    """

    @property
    def spec(self) -> global___ExecutionSpec:
        """Additional fields necessary to launch the execution.
        +optional
        """
        pass
    @property
    def inputs(self) -> flyteidl.core.literals_pb2.LiteralMap:
        """The inputs required to start the execution. All required inputs must be
        included in this map. If not required and not provided, defaults apply.
        +optional
        """
        pass
    def __init__(self,
        *,
        project : typing.Text = ...,
        domain : typing.Text = ...,
        name : typing.Text = ...,
        spec : typing.Optional[global___ExecutionSpec] = ...,
        inputs : typing.Optional[flyteidl.core.literals_pb2.LiteralMap] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"inputs",b"inputs",u"spec",b"spec"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"domain",b"domain",u"inputs",b"inputs",u"name",b"name",u"project",b"project",u"spec",b"spec"]) -> None: ...
global___ExecutionCreateRequest = ExecutionCreateRequest

class ExecutionRelaunchRequest(google.protobuf.message.Message):
    """Request to relaunch the referenced execution."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier:
        """Identifier of the workflow execution to relaunch.
        +required
        """
        pass
    name: typing.Text = ...
    """User provided value for the relaunched execution.
    If none is provided the system will generate a unique string.
    +optional
    """

    def __init__(self,
        *,
        id : typing.Optional[flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier] = ...,
        name : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"id",b"id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"id",b"id",u"name",b"name"]) -> None: ...
global___ExecutionRelaunchRequest = ExecutionRelaunchRequest

class ExecutionRecoverRequest(google.protobuf.message.Message):
    """Request to recover the referenced execution."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier:
        """Identifier of the workflow execution to recover."""
        pass
    name: typing.Text = ...
    """User provided value for the recovered execution.
    If none is provided the system will generate a unique string.
    +optional
    """

    @property
    def metadata(self) -> global___ExecutionMetadata:
        """Additional metadata which will be used to overwrite any metadata in the reference execution when triggering a recovery execution."""
        pass
    def __init__(self,
        *,
        id : typing.Optional[flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier] = ...,
        name : typing.Text = ...,
        metadata : typing.Optional[global___ExecutionMetadata] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"id",b"id",u"metadata",b"metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"id",b"id",u"metadata",b"metadata",u"name",b"name"]) -> None: ...
global___ExecutionRecoverRequest = ExecutionRecoverRequest

class ExecutionCreateResponse(google.protobuf.message.Message):
    """The unique identifier for a successfully created execution.
    If the name was *not* specified in the create request, this identifier will include a generated name.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier: ...
    def __init__(self,
        *,
        id : typing.Optional[flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"id",b"id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"id",b"id"]) -> None: ...
global___ExecutionCreateResponse = ExecutionCreateResponse

class WorkflowExecutionGetRequest(google.protobuf.message.Message):
    """A message used to fetch a single workflow execution entity.
    See :ref:`ref_flyteidl.admin.Execution` for more details
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier:
        """Uniquely identifies an individual workflow execution."""
        pass
    def __init__(self,
        *,
        id : typing.Optional[flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"id",b"id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"id",b"id"]) -> None: ...
global___WorkflowExecutionGetRequest = WorkflowExecutionGetRequest

class Execution(google.protobuf.message.Message):
    """A workflow execution represents an instantiated workflow, including all inputs and additional
    metadata as well as computed results included state, outputs, and duration-based attributes.
    Used as a response object used in Get and List execution requests.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    SPEC_FIELD_NUMBER: builtins.int
    CLOSURE_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier:
        """Unique identifier of the workflow execution."""
        pass
    @property
    def spec(self) -> global___ExecutionSpec:
        """User-provided configuration and inputs for launching the execution."""
        pass
    @property
    def closure(self) -> global___ExecutionClosure:
        """Execution results."""
        pass
    def __init__(self,
        *,
        id : typing.Optional[flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier] = ...,
        spec : typing.Optional[global___ExecutionSpec] = ...,
        closure : typing.Optional[global___ExecutionClosure] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"closure",b"closure",u"id",b"id",u"spec",b"spec"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"closure",b"closure",u"id",b"id",u"spec",b"spec"]) -> None: ...
global___Execution = Execution

class ExecutionList(google.protobuf.message.Message):
    """Used as a response for request to list executions.
    See :ref:`ref_flyteidl.admin.Execution` for more details
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXECUTIONS_FIELD_NUMBER: builtins.int
    TOKEN_FIELD_NUMBER: builtins.int
    @property
    def executions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Execution]: ...
    token: typing.Text = ...
    """In the case of multiple pages of results, the server-provided token can be used to fetch the next page
    in a query. If there are no more results, this value will be empty.
    """

    def __init__(self,
        *,
        executions : typing.Optional[typing.Iterable[global___Execution]] = ...,
        token : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"executions",b"executions",u"token",b"token"]) -> None: ...
global___ExecutionList = ExecutionList

class LiteralMapBlob(google.protobuf.message.Message):
    """Input/output data can represented by actual values or a link to where values are stored"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    VALUES_FIELD_NUMBER: builtins.int
    URI_FIELD_NUMBER: builtins.int
    @property
    def values(self) -> flyteidl.core.literals_pb2.LiteralMap:
        """Data in LiteralMap format"""
        pass
    uri: typing.Text = ...
    """In the event that the map is too large, we return a uri to the data"""

    def __init__(self,
        *,
        values : typing.Optional[flyteidl.core.literals_pb2.LiteralMap] = ...,
        uri : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"data",b"data",u"uri",b"uri",u"values",b"values"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"data",b"data",u"uri",b"uri",u"values",b"values"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"data",b"data"]) -> typing.Optional[typing_extensions.Literal["values","uri"]]: ...
global___LiteralMapBlob = LiteralMapBlob

class AbortMetadata(google.protobuf.message.Message):
    """Specifies metadata around an aborted workflow execution."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CAUSE_FIELD_NUMBER: builtins.int
    PRINCIPAL_FIELD_NUMBER: builtins.int
    cause: typing.Text = ...
    """In the case of a user-specified abort, this will pass along the user-supplied cause."""

    principal: typing.Text = ...
    """Identifies the entity (if any) responsible for terminating the execution"""

    def __init__(self,
        *,
        cause : typing.Text = ...,
        principal : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"cause",b"cause",u"principal",b"principal"]) -> None: ...
global___AbortMetadata = AbortMetadata

class ExecutionClosure(google.protobuf.message.Message):
    """Encapsulates the results of the Execution"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    OUTPUTS_FIELD_NUMBER: builtins.int
    ERROR_FIELD_NUMBER: builtins.int
    ABORT_CAUSE_FIELD_NUMBER: builtins.int
    ABORT_METADATA_FIELD_NUMBER: builtins.int
    OUTPUT_DATA_FIELD_NUMBER: builtins.int
    COMPUTED_INPUTS_FIELD_NUMBER: builtins.int
    PHASE_FIELD_NUMBER: builtins.int
    STARTED_AT_FIELD_NUMBER: builtins.int
    DURATION_FIELD_NUMBER: builtins.int
    CREATED_AT_FIELD_NUMBER: builtins.int
    UPDATED_AT_FIELD_NUMBER: builtins.int
    NOTIFICATIONS_FIELD_NUMBER: builtins.int
    WORKFLOW_ID_FIELD_NUMBER: builtins.int
    @property
    def outputs(self) -> global___LiteralMapBlob:
        """Output URI in the case of a successful execution."""
        pass
    @property
    def error(self) -> flyteidl.core.execution_pb2.ExecutionError:
        """Error information in the case of a failed execution."""
        pass
    abort_cause: typing.Text = ...
    """In the case of a user-specified abort, this will pass along the user-supplied cause."""

    @property
    def abort_metadata(self) -> global___AbortMetadata:
        """In the case of a user-specified abort, this will pass along the user and their supplied cause."""
        pass
    @property
    def output_data(self) -> flyteidl.core.literals_pb2.LiteralMap:
        """Raw output data produced by this execution."""
        pass
    @property
    def computed_inputs(self) -> flyteidl.core.literals_pb2.LiteralMap:
        """Inputs computed and passed for execution.
        computed_inputs depends on inputs in ExecutionSpec, fixed and default inputs in launch plan
        """
        pass
    phase: flyteidl.core.execution_pb2.WorkflowExecution.Phase.V = ...
    """Most recent recorded phase for the execution."""

    @property
    def started_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Reported time at which the execution began running."""
        pass
    @property
    def duration(self) -> google.protobuf.duration_pb2.Duration:
        """The amount of time the execution spent running."""
        pass
    @property
    def created_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Reported time at which the execution was created."""
        pass
    @property
    def updated_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Reported time at which the execution was last updated."""
        pass
    @property
    def notifications(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[flyteidl.admin.common_pb2.Notification]:
        """The notification settings to use after merging the CreateExecutionRequest and the launch plan
        notification settings. An execution launched with notifications will always prefer that definition
        to notifications defined statically in a launch plan.
        """
        pass
    @property
    def workflow_id(self) -> flyteidl.core.identifier_pb2.Identifier:
        """Identifies the workflow definition for this execution."""
        pass
    def __init__(self,
        *,
        outputs : typing.Optional[global___LiteralMapBlob] = ...,
        error : typing.Optional[flyteidl.core.execution_pb2.ExecutionError] = ...,
        abort_cause : typing.Text = ...,
        abort_metadata : typing.Optional[global___AbortMetadata] = ...,
        output_data : typing.Optional[flyteidl.core.literals_pb2.LiteralMap] = ...,
        computed_inputs : typing.Optional[flyteidl.core.literals_pb2.LiteralMap] = ...,
        phase : flyteidl.core.execution_pb2.WorkflowExecution.Phase.V = ...,
        started_at : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        duration : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        created_at : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        updated_at : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        notifications : typing.Optional[typing.Iterable[flyteidl.admin.common_pb2.Notification]] = ...,
        workflow_id : typing.Optional[flyteidl.core.identifier_pb2.Identifier] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"abort_cause",b"abort_cause",u"abort_metadata",b"abort_metadata",u"computed_inputs",b"computed_inputs",u"created_at",b"created_at",u"duration",b"duration",u"error",b"error",u"output_data",b"output_data",u"output_result",b"output_result",u"outputs",b"outputs",u"started_at",b"started_at",u"updated_at",b"updated_at",u"workflow_id",b"workflow_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"abort_cause",b"abort_cause",u"abort_metadata",b"abort_metadata",u"computed_inputs",b"computed_inputs",u"created_at",b"created_at",u"duration",b"duration",u"error",b"error",u"notifications",b"notifications",u"output_data",b"output_data",u"output_result",b"output_result",u"outputs",b"outputs",u"phase",b"phase",u"started_at",b"started_at",u"updated_at",b"updated_at",u"workflow_id",b"workflow_id"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"output_result",b"output_result"]) -> typing.Optional[typing_extensions.Literal["outputs","error","abort_cause","abort_metadata","output_data"]]: ...
global___ExecutionClosure = ExecutionClosure

class SystemMetadata(google.protobuf.message.Message):
    """Represents system, rather than user-facing, metadata about an execution."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXECUTION_CLUSTER_FIELD_NUMBER: builtins.int
    execution_cluster: typing.Text = ...
    """Which execution cluster this execution ran on."""

    def __init__(self,
        *,
        execution_cluster : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"execution_cluster",b"execution_cluster"]) -> None: ...
global___SystemMetadata = SystemMetadata

class ExecutionMetadata(google.protobuf.message.Message):
    """Represents attributes about an execution which are not required to launch the execution but are useful to record.
    These attributes are assigned at launch time and do not change.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ExecutionMode(_ExecutionMode, metaclass=_ExecutionModeEnumTypeWrapper):
        """The method by which this execution was launched."""
        pass
    class _ExecutionMode:
        V = typing.NewType('V', builtins.int)
    class _ExecutionModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ExecutionMode.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        MANUAL = ExecutionMetadata.ExecutionMode.V(0)
        """The default execution mode, MANUAL implies that an execution was launched by an individual."""

        SCHEDULED = ExecutionMetadata.ExecutionMode.V(1)
        """A schedule triggered this execution launch."""

        SYSTEM = ExecutionMetadata.ExecutionMode.V(2)
        """A system process was responsible for launching this execution rather an individual."""

        RELAUNCH = ExecutionMetadata.ExecutionMode.V(3)
        """This execution was launched with identical inputs as a previous execution."""

        CHILD_WORKFLOW = ExecutionMetadata.ExecutionMode.V(4)
        """This execution was triggered by another execution."""

        RECOVERED = ExecutionMetadata.ExecutionMode.V(5)
        """This execution was recovered from another execution."""


    MANUAL = ExecutionMetadata.ExecutionMode.V(0)
    """The default execution mode, MANUAL implies that an execution was launched by an individual."""

    SCHEDULED = ExecutionMetadata.ExecutionMode.V(1)
    """A schedule triggered this execution launch."""

    SYSTEM = ExecutionMetadata.ExecutionMode.V(2)
    """A system process was responsible for launching this execution rather an individual."""

    RELAUNCH = ExecutionMetadata.ExecutionMode.V(3)
    """This execution was launched with identical inputs as a previous execution."""

    CHILD_WORKFLOW = ExecutionMetadata.ExecutionMode.V(4)
    """This execution was triggered by another execution."""

    RECOVERED = ExecutionMetadata.ExecutionMode.V(5)
    """This execution was recovered from another execution."""


    MODE_FIELD_NUMBER: builtins.int
    PRINCIPAL_FIELD_NUMBER: builtins.int
    NESTING_FIELD_NUMBER: builtins.int
    SCHEDULED_AT_FIELD_NUMBER: builtins.int
    PARENT_NODE_EXECUTION_FIELD_NUMBER: builtins.int
    REFERENCE_EXECUTION_FIELD_NUMBER: builtins.int
    SYSTEM_METADATA_FIELD_NUMBER: builtins.int
    mode: global___ExecutionMetadata.ExecutionMode.V = ...
    principal: typing.Text = ...
    """Identifier of the entity that triggered this execution.
    For systems using back-end authentication any value set here will be discarded in favor of the
    authenticated user context.
    """

    nesting: builtins.int = ...
    """Indicates the nestedness of this execution.
    If a user launches a workflow execution, the default nesting is 0.
    If this execution further launches a workflow (child workflow), the nesting level is incremented by 0 => 1
    Generally, if workflow at nesting level k launches a workflow then the child workflow will have
    nesting = k + 1.
    """

    @property
    def scheduled_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """For scheduled executions, the requested time for execution for this specific schedule invocation."""
        pass
    @property
    def parent_node_execution(self) -> flyteidl.core.identifier_pb2.NodeExecutionIdentifier:
        """Which subworkflow node (if any) launched this execution"""
        pass
    @property
    def reference_execution(self) -> flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier:
        """Optional, a reference workflow execution related to this execution.
        In the case of a relaunch, this references the original workflow execution.
        """
        pass
    @property
    def system_metadata(self) -> global___SystemMetadata:
        """Optional, platform-specific metadata about the execution.
        In this the future this may be gated behind an ACL or some sort of authorization.
        """
        pass
    def __init__(self,
        *,
        mode : global___ExecutionMetadata.ExecutionMode.V = ...,
        principal : typing.Text = ...,
        nesting : builtins.int = ...,
        scheduled_at : typing.Optional[google.protobuf.timestamp_pb2.Timestamp] = ...,
        parent_node_execution : typing.Optional[flyteidl.core.identifier_pb2.NodeExecutionIdentifier] = ...,
        reference_execution : typing.Optional[flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier] = ...,
        system_metadata : typing.Optional[global___SystemMetadata] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"parent_node_execution",b"parent_node_execution",u"reference_execution",b"reference_execution",u"scheduled_at",b"scheduled_at",u"system_metadata",b"system_metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"mode",b"mode",u"nesting",b"nesting",u"parent_node_execution",b"parent_node_execution",u"principal",b"principal",u"reference_execution",b"reference_execution",u"scheduled_at",b"scheduled_at",u"system_metadata",b"system_metadata"]) -> None: ...
global___ExecutionMetadata = ExecutionMetadata

class NotificationList(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NOTIFICATIONS_FIELD_NUMBER: builtins.int
    @property
    def notifications(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[flyteidl.admin.common_pb2.Notification]: ...
    def __init__(self,
        *,
        notifications : typing.Optional[typing.Iterable[flyteidl.admin.common_pb2.Notification]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"notifications",b"notifications"]) -> None: ...
global___NotificationList = NotificationList

class ExecutionSpec(google.protobuf.message.Message):
    """An ExecutionSpec encompasses all data used to launch this execution. The Spec does not change over the lifetime
    of an execution as it progresses across phase changes.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    LAUNCH_PLAN_FIELD_NUMBER: builtins.int
    INPUTS_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    NOTIFICATIONS_FIELD_NUMBER: builtins.int
    DISABLE_ALL_FIELD_NUMBER: builtins.int
    LABELS_FIELD_NUMBER: builtins.int
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    SECURITY_CONTEXT_FIELD_NUMBER: builtins.int
    AUTH_ROLE_FIELD_NUMBER: builtins.int
    QUALITY_OF_SERVICE_FIELD_NUMBER: builtins.int
    MAX_PARALLELISM_FIELD_NUMBER: builtins.int
    @property
    def launch_plan(self) -> flyteidl.core.identifier_pb2.Identifier:
        """Launch plan to be executed"""
        pass
    @property
    def inputs(self) -> flyteidl.core.literals_pb2.LiteralMap:
        """Input values to be passed for the execution"""
        pass
    @property
    def metadata(self) -> global___ExecutionMetadata:
        """Metadata for the execution"""
        pass
    @property
    def notifications(self) -> global___NotificationList:
        """List of notifications based on Execution status transitions
        When this list is not empty it is used rather than any notifications defined in the referenced launch plan.
        When this list is empty, the notifications defined for the launch plan will be applied.
        """
        pass
    disable_all: builtins.bool = ...
    """This should be set to true if all notifications are intended to be disabled for this execution."""

    @property
    def labels(self) -> flyteidl.admin.common_pb2.Labels:
        """Labels to apply to the execution resource."""
        pass
    @property
    def annotations(self) -> flyteidl.admin.common_pb2.Annotations:
        """Annotations to apply to the execution resource."""
        pass
    @property
    def security_context(self) -> flyteidl.core.security_pb2.SecurityContext:
        """Optional: security context override to apply this execution."""
        pass
    @property
    def auth_role(self) -> flyteidl.admin.common_pb2.AuthRole:
        """Optional: auth override to apply this execution."""
        pass
    @property
    def quality_of_service(self) -> flyteidl.core.execution_pb2.QualityOfService:
        """Indicates the runtime priority of the execution."""
        pass
    max_parallelism: builtins.int = ...
    """Controls the maximum number of task nodes that can be run in parallel for the entire workflow.
    This is useful to achieve fairness. Note: MapTasks are regarded as one unit,
    and parallelism/concurrency of MapTasks is independent from this.
    """

    def __init__(self,
        *,
        launch_plan : typing.Optional[flyteidl.core.identifier_pb2.Identifier] = ...,
        inputs : typing.Optional[flyteidl.core.literals_pb2.LiteralMap] = ...,
        metadata : typing.Optional[global___ExecutionMetadata] = ...,
        notifications : typing.Optional[global___NotificationList] = ...,
        disable_all : builtins.bool = ...,
        labels : typing.Optional[flyteidl.admin.common_pb2.Labels] = ...,
        annotations : typing.Optional[flyteidl.admin.common_pb2.Annotations] = ...,
        security_context : typing.Optional[flyteidl.core.security_pb2.SecurityContext] = ...,
        auth_role : typing.Optional[flyteidl.admin.common_pb2.AuthRole] = ...,
        quality_of_service : typing.Optional[flyteidl.core.execution_pb2.QualityOfService] = ...,
        max_parallelism : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"annotations",b"annotations",u"auth_role",b"auth_role",u"disable_all",b"disable_all",u"inputs",b"inputs",u"labels",b"labels",u"launch_plan",b"launch_plan",u"metadata",b"metadata",u"notification_overrides",b"notification_overrides",u"notifications",b"notifications",u"quality_of_service",b"quality_of_service",u"security_context",b"security_context"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"annotations",b"annotations",u"auth_role",b"auth_role",u"disable_all",b"disable_all",u"inputs",b"inputs",u"labels",b"labels",u"launch_plan",b"launch_plan",u"max_parallelism",b"max_parallelism",u"metadata",b"metadata",u"notification_overrides",b"notification_overrides",u"notifications",b"notifications",u"quality_of_service",b"quality_of_service",u"security_context",b"security_context"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"notification_overrides",b"notification_overrides"]) -> typing.Optional[typing_extensions.Literal["notifications","disable_all"]]: ...
global___ExecutionSpec = ExecutionSpec

class ExecutionTerminateRequest(google.protobuf.message.Message):
    """Request to terminate an in-progress execution.  This action is irreversible.
    If an execution is already terminated, this request will simply be a no-op.
    This request will fail if it references a non-existent execution.
    If the request succeeds the phase "ABORTED" will be recorded for the termination
    with the optional cause added to the output_result.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    CAUSE_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier:
        """Uniquely identifies the individual workflow execution to be terminated."""
        pass
    cause: typing.Text = ...
    """Optional reason for aborting."""

    def __init__(self,
        *,
        id : typing.Optional[flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier] = ...,
        cause : typing.Text = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"id",b"id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"cause",b"cause",u"id",b"id"]) -> None: ...
global___ExecutionTerminateRequest = ExecutionTerminateRequest

class ExecutionTerminateResponse(google.protobuf.message.Message):
    """Purposefully empty, may be populated in the future."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    def __init__(self,
        ) -> None: ...
global___ExecutionTerminateResponse = ExecutionTerminateResponse

class WorkflowExecutionGetDataRequest(google.protobuf.message.Message):
    """Request structure to fetch inputs, output and other data produced by an execution.
    By default this data is not returned inline in :ref:`ref_flyteidl.admin.WorkflowExecutionGetRequest`
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ID_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier:
        """The identifier of the execution for which to fetch inputs and outputs."""
        pass
    def __init__(self,
        *,
        id : typing.Optional[flyteidl.core.identifier_pb2.WorkflowExecutionIdentifier] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"id",b"id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"id",b"id"]) -> None: ...
global___WorkflowExecutionGetDataRequest = WorkflowExecutionGetDataRequest

class WorkflowExecutionGetDataResponse(google.protobuf.message.Message):
    """Response structure for WorkflowExecutionGetDataRequest which contains inputs and outputs for an execution."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    OUTPUTS_FIELD_NUMBER: builtins.int
    INPUTS_FIELD_NUMBER: builtins.int
    FULL_INPUTS_FIELD_NUMBER: builtins.int
    FULL_OUTPUTS_FIELD_NUMBER: builtins.int
    @property
    def outputs(self) -> flyteidl.admin.common_pb2.UrlBlob:
        """Signed url to fetch a core.LiteralMap of execution outputs.
        Deprecated: Please use full_outputs instead.
        """
        pass
    @property
    def inputs(self) -> flyteidl.admin.common_pb2.UrlBlob:
        """Signed url to fetch a core.LiteralMap of execution inputs.
        Deprecated: Please use full_inputs instead.
        """
        pass
    @property
    def full_inputs(self) -> flyteidl.core.literals_pb2.LiteralMap:
        """Full_inputs will only be populated if they are under a configured size threshold."""
        pass
    @property
    def full_outputs(self) -> flyteidl.core.literals_pb2.LiteralMap:
        """Full_outputs will only be populated if they are under a configured size threshold."""
        pass
    def __init__(self,
        *,
        outputs : typing.Optional[flyteidl.admin.common_pb2.UrlBlob] = ...,
        inputs : typing.Optional[flyteidl.admin.common_pb2.UrlBlob] = ...,
        full_inputs : typing.Optional[flyteidl.core.literals_pb2.LiteralMap] = ...,
        full_outputs : typing.Optional[flyteidl.core.literals_pb2.LiteralMap] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"full_inputs",b"full_inputs",u"full_outputs",b"full_outputs",u"inputs",b"inputs",u"outputs",b"outputs"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"full_inputs",b"full_inputs",u"full_outputs",b"full_outputs",u"inputs",b"inputs",u"outputs",b"outputs"]) -> None: ...
global___WorkflowExecutionGetDataResponse = WorkflowExecutionGetDataResponse
