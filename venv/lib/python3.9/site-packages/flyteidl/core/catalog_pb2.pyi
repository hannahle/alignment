"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import flyteidl.core.identifier_pb2
import google.protobuf.descriptor
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class CatalogCacheStatus(_CatalogCacheStatus, metaclass=_CatalogCacheStatusEnumTypeWrapper):
    """Indicates the status of CatalogCaching. The reason why this is not embedded in TaskNodeMetadata is, that we may use for other types of nodes as well in the future"""
    pass
class _CatalogCacheStatus:
    V = typing.NewType('V', builtins.int)
class _CatalogCacheStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_CatalogCacheStatus.V], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    CACHE_DISABLED = CatalogCacheStatus.V(0)
    """Used to indicate that caching was disabled"""

    CACHE_MISS = CatalogCacheStatus.V(1)
    """Used to indicate that the cache lookup resulted in no matches"""

    CACHE_HIT = CatalogCacheStatus.V(2)
    """used to indicate that the associated artifact was a result of a previous execution"""

    CACHE_POPULATED = CatalogCacheStatus.V(3)
    """used to indicate that the resultant artifact was added to the cache"""

    CACHE_LOOKUP_FAILURE = CatalogCacheStatus.V(4)
    """Used to indicate that cache lookup failed because of an error"""

    CACHE_PUT_FAILURE = CatalogCacheStatus.V(5)
    """Used to indicate that cache lookup failed because of an error"""


CACHE_DISABLED = CatalogCacheStatus.V(0)
"""Used to indicate that caching was disabled"""

CACHE_MISS = CatalogCacheStatus.V(1)
"""Used to indicate that the cache lookup resulted in no matches"""

CACHE_HIT = CatalogCacheStatus.V(2)
"""used to indicate that the associated artifact was a result of a previous execution"""

CACHE_POPULATED = CatalogCacheStatus.V(3)
"""used to indicate that the resultant artifact was added to the cache"""

CACHE_LOOKUP_FAILURE = CatalogCacheStatus.V(4)
"""Used to indicate that cache lookup failed because of an error"""

CACHE_PUT_FAILURE = CatalogCacheStatus.V(5)
"""Used to indicate that cache lookup failed because of an error"""

global___CatalogCacheStatus = CatalogCacheStatus


class CatalogArtifactTag(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ARTIFACT_ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    artifact_id: typing.Text = ...
    """Artifact ID is generated name"""

    name: typing.Text = ...
    """Flyte computes the tag automatically, as the hash of the values"""

    def __init__(self,
        *,
        artifact_id : typing.Text = ...,
        name : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"artifact_id",b"artifact_id",u"name",b"name"]) -> None: ...
global___CatalogArtifactTag = CatalogArtifactTag

class CatalogMetadata(google.protobuf.message.Message):
    """Catalog artifact information with specific metadata"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DATASET_ID_FIELD_NUMBER: builtins.int
    ARTIFACT_TAG_FIELD_NUMBER: builtins.int
    SOURCE_TASK_EXECUTION_FIELD_NUMBER: builtins.int
    @property
    def dataset_id(self) -> flyteidl.core.identifier_pb2.Identifier:
        """Dataset ID in the catalog"""
        pass
    @property
    def artifact_tag(self) -> global___CatalogArtifactTag:
        """Artifact tag in the catalog"""
        pass
    @property
    def source_task_execution(self) -> flyteidl.core.identifier_pb2.TaskExecutionIdentifier:
        """Today we only support TaskExecutionIdentifier as a source, as catalog caching only works for task executions"""
        pass
    def __init__(self,
        *,
        dataset_id : typing.Optional[flyteidl.core.identifier_pb2.Identifier] = ...,
        artifact_tag : typing.Optional[global___CatalogArtifactTag] = ...,
        source_task_execution : typing.Optional[flyteidl.core.identifier_pb2.TaskExecutionIdentifier] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"artifact_tag",b"artifact_tag",u"dataset_id",b"dataset_id",u"source_execution",b"source_execution",u"source_task_execution",b"source_task_execution"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"artifact_tag",b"artifact_tag",u"dataset_id",b"dataset_id",u"source_execution",b"source_execution",u"source_task_execution",b"source_task_execution"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"source_execution",b"source_execution"]) -> typing.Optional[typing_extensions.Literal["source_task_execution"]]: ...
global___CatalogMetadata = CatalogMetadata
