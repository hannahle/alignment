"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import flyteidl.core.identifier_pb2
import flyteidl.core.interface_pb2
import flyteidl.core.literals_pb2
import flyteidl.core.security_pb2
import google.protobuf.descriptor
import google.protobuf.duration_pb2
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.struct_pb2
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class Resources(google.protobuf.message.Message):
    """A customizable interface to convey resources requested for a container. This can be interpreted differently for different
    container engines.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ResourceName(_ResourceName, metaclass=_ResourceNameEnumTypeWrapper):
        """Known resource names."""
        pass
    class _ResourceName:
        V = typing.NewType('V', builtins.int)
    class _ResourceNameEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ResourceName.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNKNOWN = Resources.ResourceName.V(0)
        CPU = Resources.ResourceName.V(1)
        GPU = Resources.ResourceName.V(2)
        MEMORY = Resources.ResourceName.V(3)
        STORAGE = Resources.ResourceName.V(4)
        EPHEMERAL_STORAGE = Resources.ResourceName.V(5)
        """For Kubernetes-based deployments, pods use ephemeral local storage for scratch space, caching, and for logs."""


    UNKNOWN = Resources.ResourceName.V(0)
    CPU = Resources.ResourceName.V(1)
    GPU = Resources.ResourceName.V(2)
    MEMORY = Resources.ResourceName.V(3)
    STORAGE = Resources.ResourceName.V(4)
    EPHEMERAL_STORAGE = Resources.ResourceName.V(5)
    """For Kubernetes-based deployments, pods use ephemeral local storage for scratch space, caching, and for logs."""


    class ResourceEntry(google.protobuf.message.Message):
        """Encapsulates a resource name and value."""
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        NAME_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        name: global___Resources.ResourceName.V = ...
        """Resource name."""

        value: typing.Text = ...
        """Value must be a valid k8s quantity. See
        https://github.com/kubernetes/apimachinery/blob/master/pkg/api/resource/quantity.go#L30-L80
        """

        def __init__(self,
            *,
            name : global___Resources.ResourceName.V = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"name",b"name",u"value",b"value"]) -> None: ...

    REQUESTS_FIELD_NUMBER: builtins.int
    LIMITS_FIELD_NUMBER: builtins.int
    @property
    def requests(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Resources.ResourceEntry]:
        """The desired set of resources requested. ResourceNames must be unique within the list."""
        pass
    @property
    def limits(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Resources.ResourceEntry]:
        """Defines a set of bounds (e.g. min/max) within which the task can reliably run. ResourceNames must be unique
        within the list.
        """
        pass
    def __init__(self,
        *,
        requests : typing.Optional[typing.Iterable[global___Resources.ResourceEntry]] = ...,
        limits : typing.Optional[typing.Iterable[global___Resources.ResourceEntry]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"limits",b"limits",u"requests",b"requests"]) -> None: ...
global___Resources = Resources

class RuntimeMetadata(google.protobuf.message.Message):
    """Runtime information. This is loosely defined to allow for extensibility."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class RuntimeType(_RuntimeType, metaclass=_RuntimeTypeEnumTypeWrapper):
        pass
    class _RuntimeType:
        V = typing.NewType('V', builtins.int)
    class _RuntimeTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RuntimeType.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        OTHER = RuntimeMetadata.RuntimeType.V(0)
        FLYTE_SDK = RuntimeMetadata.RuntimeType.V(1)

    OTHER = RuntimeMetadata.RuntimeType.V(0)
    FLYTE_SDK = RuntimeMetadata.RuntimeType.V(1)

    TYPE_FIELD_NUMBER: builtins.int
    VERSION_FIELD_NUMBER: builtins.int
    FLAVOR_FIELD_NUMBER: builtins.int
    type: global___RuntimeMetadata.RuntimeType.V = ...
    """Type of runtime."""

    version: typing.Text = ...
    """Version of the runtime. All versions should be backward compatible. However, certain cases call for version
    checks to ensure tighter validation or setting expectations.
    """

    flavor: typing.Text = ...
    """+optional It can be used to provide extra information about the runtime (e.g. python, golang... etc.)."""

    def __init__(self,
        *,
        type : global___RuntimeMetadata.RuntimeType.V = ...,
        version : typing.Text = ...,
        flavor : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"flavor",b"flavor",u"type",b"type",u"version",b"version"]) -> None: ...
global___RuntimeMetadata = RuntimeMetadata

class TaskMetadata(google.protobuf.message.Message):
    """Task Metadata"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    DISCOVERABLE_FIELD_NUMBER: builtins.int
    RUNTIME_FIELD_NUMBER: builtins.int
    TIMEOUT_FIELD_NUMBER: builtins.int
    RETRIES_FIELD_NUMBER: builtins.int
    DISCOVERY_VERSION_FIELD_NUMBER: builtins.int
    DEPRECATED_ERROR_MESSAGE_FIELD_NUMBER: builtins.int
    INTERRUPTIBLE_FIELD_NUMBER: builtins.int
    discoverable: builtins.bool = ...
    """Indicates whether the system should attempt to lookup this task's output to avoid duplication of work."""

    @property
    def runtime(self) -> global___RuntimeMetadata:
        """Runtime information about the task."""
        pass
    @property
    def timeout(self) -> google.protobuf.duration_pb2.Duration:
        """The overall timeout of a task including user-triggered retries."""
        pass
    @property
    def retries(self) -> flyteidl.core.literals_pb2.RetryStrategy:
        """Number of retries per task."""
        pass
    discovery_version: typing.Text = ...
    """Indicates a logical version to apply to this task for the purpose of discovery."""

    deprecated_error_message: typing.Text = ...
    """If set, this indicates that this task is deprecated.  This will enable owners of tasks to notify consumers
    of the ending of support for a given task.
    """

    interruptible: builtins.bool = ...
    def __init__(self,
        *,
        discoverable : builtins.bool = ...,
        runtime : typing.Optional[global___RuntimeMetadata] = ...,
        timeout : typing.Optional[google.protobuf.duration_pb2.Duration] = ...,
        retries : typing.Optional[flyteidl.core.literals_pb2.RetryStrategy] = ...,
        discovery_version : typing.Text = ...,
        deprecated_error_message : typing.Text = ...,
        interruptible : builtins.bool = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"interruptible",b"interruptible",u"interruptible_value",b"interruptible_value",u"retries",b"retries",u"runtime",b"runtime",u"timeout",b"timeout"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"deprecated_error_message",b"deprecated_error_message",u"discoverable",b"discoverable",u"discovery_version",b"discovery_version",u"interruptible",b"interruptible",u"interruptible_value",b"interruptible_value",u"retries",b"retries",u"runtime",b"runtime",u"timeout",b"timeout"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"interruptible_value",b"interruptible_value"]) -> typing.Optional[typing_extensions.Literal["interruptible"]]: ...
global___TaskMetadata = TaskMetadata

class TaskTemplate(google.protobuf.message.Message):
    """A Task structure that uniquely identifies a task in the system
    Tasks are registered as a first step in the system.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class ConfigEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    ID_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    INTERFACE_FIELD_NUMBER: builtins.int
    CUSTOM_FIELD_NUMBER: builtins.int
    CONTAINER_FIELD_NUMBER: builtins.int
    K8S_POD_FIELD_NUMBER: builtins.int
    TASK_TYPE_VERSION_FIELD_NUMBER: builtins.int
    SECURITY_CONTEXT_FIELD_NUMBER: builtins.int
    CONFIG_FIELD_NUMBER: builtins.int
    @property
    def id(self) -> flyteidl.core.identifier_pb2.Identifier:
        """Auto generated taskId by the system. Task Id uniquely identifies this task globally."""
        pass
    type: typing.Text = ...
    """A predefined yet extensible Task type identifier. This can be used to customize any of the components. If no
    extensions are provided in the system, Flyte will resolve the this task to its TaskCategory and default the
    implementation registered for the TaskCategory.
    """

    @property
    def metadata(self) -> global___TaskMetadata:
        """Extra metadata about the task."""
        pass
    @property
    def interface(self) -> flyteidl.core.interface_pb2.TypedInterface:
        """A strongly typed interface for the task. This enables others to use this task within a workflow and guarantees
        compile-time validation of the workflow to avoid costly runtime failures.
        """
        pass
    @property
    def custom(self) -> google.protobuf.struct_pb2.Struct:
        """Custom data about the task. This is extensible to allow various plugins in the system."""
        pass
    @property
    def container(self) -> global___Container: ...
    @property
    def k8s_pod(self) -> global___K8sPod: ...
    task_type_version: builtins.int = ...
    """This can be used to customize task handling at execution time for the same task type."""

    @property
    def security_context(self) -> flyteidl.core.security_pb2.SecurityContext:
        """security_context encapsulates security attributes requested to run this task."""
        pass
    @property
    def config(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Metadata about the custom defined for this task. This is extensible to allow various plugins in the system
        to use as required.
        reserve the field numbers 1 through 15 for very frequently occurring message elements
        """
        pass
    def __init__(self,
        *,
        id : typing.Optional[flyteidl.core.identifier_pb2.Identifier] = ...,
        type : typing.Text = ...,
        metadata : typing.Optional[global___TaskMetadata] = ...,
        interface : typing.Optional[flyteidl.core.interface_pb2.TypedInterface] = ...,
        custom : typing.Optional[google.protobuf.struct_pb2.Struct] = ...,
        container : typing.Optional[global___Container] = ...,
        k8s_pod : typing.Optional[global___K8sPod] = ...,
        task_type_version : builtins.int = ...,
        security_context : typing.Optional[flyteidl.core.security_pb2.SecurityContext] = ...,
        config : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"container",b"container",u"custom",b"custom",u"id",b"id",u"interface",b"interface",u"k8s_pod",b"k8s_pod",u"metadata",b"metadata",u"security_context",b"security_context",u"target",b"target"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"config",b"config",u"container",b"container",u"custom",b"custom",u"id",b"id",u"interface",b"interface",u"k8s_pod",b"k8s_pod",u"metadata",b"metadata",u"security_context",b"security_context",u"target",b"target",u"task_type_version",b"task_type_version",u"type",b"type"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"target",b"target"]) -> typing.Optional[typing_extensions.Literal["container","k8s_pod"]]: ...
global___TaskTemplate = TaskTemplate

class ContainerPort(google.protobuf.message.Message):
    """----------------- First class Plugins

    Defines port properties for a container.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CONTAINER_PORT_FIELD_NUMBER: builtins.int
    container_port: builtins.int = ...
    """Number of port to expose on the pod's IP address.
    This must be a valid port number, 0 < x < 65536.
    """

    def __init__(self,
        *,
        container_port : builtins.int = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"container_port",b"container_port"]) -> None: ...
global___ContainerPort = ContainerPort

class Container(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    IMAGE_FIELD_NUMBER: builtins.int
    COMMAND_FIELD_NUMBER: builtins.int
    ARGS_FIELD_NUMBER: builtins.int
    RESOURCES_FIELD_NUMBER: builtins.int
    ENV_FIELD_NUMBER: builtins.int
    CONFIG_FIELD_NUMBER: builtins.int
    PORTS_FIELD_NUMBER: builtins.int
    DATA_CONFIG_FIELD_NUMBER: builtins.int
    image: typing.Text = ...
    """Container image url. Eg: docker/redis:latest"""

    @property
    def command(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Command to be executed, if not provided, the default entrypoint in the container image will be used."""
        pass
    @property
    def args(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """These will default to Flyte given paths. If provided, the system will not append known paths. If the task still
        needs flyte's inputs and outputs path, add $(FLYTE_INPUT_FILE), $(FLYTE_OUTPUT_FILE) wherever makes sense and the
        system will populate these before executing the container.
        """
        pass
    @property
    def resources(self) -> global___Resources:
        """Container resources requirement as specified by the container engine."""
        pass
    @property
    def env(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[flyteidl.core.literals_pb2.KeyValuePair]:
        """Environment variables will be set as the container is starting up."""
        pass
    @property
    def config(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[flyteidl.core.literals_pb2.KeyValuePair]:
        """Allows extra configs to be available for the container.
        TODO: elaborate on how configs will become available.
        Deprecated, please use TaskTemplate.config instead.
        """
        pass
    @property
    def ports(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ContainerPort]:
        """Ports to open in the container. This feature is not supported by all execution engines. (e.g. supported on K8s but
        not supported on AWS Batch)
        Only K8s
        """
        pass
    @property
    def data_config(self) -> global___DataLoadingConfig:
        """BETA: Optional configuration for DataLoading. If not specified, then default values are used.
        This makes it possible to to run a completely portable container, that uses inputs and outputs
        only from the local file-system and without having any reference to flyteidl. This is supported only on K8s at the moment.
        If data loading is enabled, then data will be mounted in accompanying directories specified in the DataLoadingConfig. If the directories
        are not specified, inputs will be mounted onto and outputs will be uploaded from a pre-determined file-system path. Refer to the documentation
        to understand the default paths.
        Only K8s
        """
        pass
    def __init__(self,
        *,
        image : typing.Text = ...,
        command : typing.Optional[typing.Iterable[typing.Text]] = ...,
        args : typing.Optional[typing.Iterable[typing.Text]] = ...,
        resources : typing.Optional[global___Resources] = ...,
        env : typing.Optional[typing.Iterable[flyteidl.core.literals_pb2.KeyValuePair]] = ...,
        config : typing.Optional[typing.Iterable[flyteidl.core.literals_pb2.KeyValuePair]] = ...,
        ports : typing.Optional[typing.Iterable[global___ContainerPort]] = ...,
        data_config : typing.Optional[global___DataLoadingConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"data_config",b"data_config",u"resources",b"resources"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"args",b"args",u"command",b"command",u"config",b"config",u"data_config",b"data_config",u"env",b"env",u"image",b"image",u"ports",b"ports",u"resources",b"resources"]) -> None: ...
global___Container = Container

class IOStrategy(google.protobuf.message.Message):
    """Strategy to use when dealing with Blob, Schema, or multipart blob data (large datasets)"""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class DownloadMode(_DownloadMode, metaclass=_DownloadModeEnumTypeWrapper):
        """Mode to use for downloading"""
        pass
    class _DownloadMode:
        V = typing.NewType('V', builtins.int)
    class _DownloadModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_DownloadMode.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        DOWNLOAD_EAGER = IOStrategy.DownloadMode.V(0)
        """All data will be downloaded before the main container is executed"""

        DOWNLOAD_STREAM = IOStrategy.DownloadMode.V(1)
        """Data will be downloaded as a stream and an End-Of-Stream marker will be written to indicate all data has been downloaded. Refer to protocol for details"""

        DO_NOT_DOWNLOAD = IOStrategy.DownloadMode.V(2)
        """Large objects (offloaded) will not be downloaded"""


    DOWNLOAD_EAGER = IOStrategy.DownloadMode.V(0)
    """All data will be downloaded before the main container is executed"""

    DOWNLOAD_STREAM = IOStrategy.DownloadMode.V(1)
    """Data will be downloaded as a stream and an End-Of-Stream marker will be written to indicate all data has been downloaded. Refer to protocol for details"""

    DO_NOT_DOWNLOAD = IOStrategy.DownloadMode.V(2)
    """Large objects (offloaded) will not be downloaded"""


    class UploadMode(_UploadMode, metaclass=_UploadModeEnumTypeWrapper):
        """Mode to use for uploading"""
        pass
    class _UploadMode:
        V = typing.NewType('V', builtins.int)
    class _UploadModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_UploadMode.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UPLOAD_ON_EXIT = IOStrategy.UploadMode.V(0)
        """All data will be uploaded after the main container exits"""

        UPLOAD_EAGER = IOStrategy.UploadMode.V(1)
        """Data will be uploaded as it appears. Refer to protocol specification for details"""

        DO_NOT_UPLOAD = IOStrategy.UploadMode.V(2)
        """Data will not be uploaded, only references will be written"""


    UPLOAD_ON_EXIT = IOStrategy.UploadMode.V(0)
    """All data will be uploaded after the main container exits"""

    UPLOAD_EAGER = IOStrategy.UploadMode.V(1)
    """Data will be uploaded as it appears. Refer to protocol specification for details"""

    DO_NOT_UPLOAD = IOStrategy.UploadMode.V(2)
    """Data will not be uploaded, only references will be written"""


    DOWNLOAD_MODE_FIELD_NUMBER: builtins.int
    UPLOAD_MODE_FIELD_NUMBER: builtins.int
    download_mode: global___IOStrategy.DownloadMode.V = ...
    """Mode to use to manage downloads"""

    upload_mode: global___IOStrategy.UploadMode.V = ...
    """Mode to use to manage uploads"""

    def __init__(self,
        *,
        download_mode : global___IOStrategy.DownloadMode.V = ...,
        upload_mode : global___IOStrategy.UploadMode.V = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"download_mode",b"download_mode",u"upload_mode",b"upload_mode"]) -> None: ...
global___IOStrategy = IOStrategy

class DataLoadingConfig(google.protobuf.message.Message):
    """This configuration allows executing raw containers in Flyte using the Flyte CoPilot system.
    Flyte CoPilot, eliminates the needs of flytekit or sdk inside the container. Any inputs required by the users container are side-loaded in the input_path
    Any outputs generated by the user container - within output_path are automatically uploaded.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class LiteralMapFormat(_LiteralMapFormat, metaclass=_LiteralMapFormatEnumTypeWrapper):
        """LiteralMapFormat decides the encoding format in which the input metadata should be made available to the containers.
        If the user has access to the protocol buffer definitions, it is recommended to use the PROTO format.
        JSON and YAML do not need any protobuf definitions to read it
        All remote references in core.LiteralMap are replaced with local filesystem references (the data is downloaded to local filesystem)
        """
        pass
    class _LiteralMapFormat:
        V = typing.NewType('V', builtins.int)
    class _LiteralMapFormatEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_LiteralMapFormat.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        JSON = DataLoadingConfig.LiteralMapFormat.V(0)
        """JSON / YAML for the metadata (which contains inlined primitive values). The representation is inline with the standard json specification as specified - https://www.json.org/json-en.html"""

        YAML = DataLoadingConfig.LiteralMapFormat.V(1)
        PROTO = DataLoadingConfig.LiteralMapFormat.V(2)
        """Proto is a serialized binary of `core.LiteralMap` defined in flyteidl/core"""


    JSON = DataLoadingConfig.LiteralMapFormat.V(0)
    """JSON / YAML for the metadata (which contains inlined primitive values). The representation is inline with the standard json specification as specified - https://www.json.org/json-en.html"""

    YAML = DataLoadingConfig.LiteralMapFormat.V(1)
    PROTO = DataLoadingConfig.LiteralMapFormat.V(2)
    """Proto is a serialized binary of `core.LiteralMap` defined in flyteidl/core"""


    ENABLED_FIELD_NUMBER: builtins.int
    INPUT_PATH_FIELD_NUMBER: builtins.int
    OUTPUT_PATH_FIELD_NUMBER: builtins.int
    FORMAT_FIELD_NUMBER: builtins.int
    IO_STRATEGY_FIELD_NUMBER: builtins.int
    enabled: builtins.bool = ...
    """Flag enables DataLoading Config. If this is not set, data loading will not be used!"""

    input_path: typing.Text = ...
    """File system path (start at root). This folder will contain all the inputs exploded to a separate file.
    Example, if the input interface needs (x: int, y: blob, z: multipart_blob) and the input path is "/var/flyte/inputs", then the file system will look like
    /var/flyte/inputs/inputs.<metadata format dependent -> .pb .json .yaml> -> Format as defined previously. The Blob and Multipart blob will reference local filesystem instead of remote locations
    /var/flyte/inputs/x -> X is a file that contains the value of x (integer) in string format
    /var/flyte/inputs/y -> Y is a file in Binary format
    /var/flyte/inputs/z/... -> Note Z itself is a directory
    More information about the protocol - refer to docs #TODO reference docs here
    """

    output_path: typing.Text = ...
    """File system path (start at root). This folder should contain all the outputs for the task as individual files and/or an error text file"""

    format: global___DataLoadingConfig.LiteralMapFormat.V = ...
    """In the inputs folder, there will be an additional summary/metadata file that contains references to all files or inlined primitive values.
    This format decides the actual encoding for the data. Refer to the encoding to understand the specifics of the contents and the encoding
    """

    @property
    def io_strategy(self) -> global___IOStrategy: ...
    def __init__(self,
        *,
        enabled : builtins.bool = ...,
        input_path : typing.Text = ...,
        output_path : typing.Text = ...,
        format : global___DataLoadingConfig.LiteralMapFormat.V = ...,
        io_strategy : typing.Optional[global___IOStrategy] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"io_strategy",b"io_strategy"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"enabled",b"enabled",u"format",b"format",u"input_path",b"input_path",u"io_strategy",b"io_strategy",u"output_path",b"output_path"]) -> None: ...
global___DataLoadingConfig = DataLoadingConfig

class K8sPod(google.protobuf.message.Message):
    """Defines a pod spec and additional pod metadata that is created when a task is executed."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    METADATA_FIELD_NUMBER: builtins.int
    POD_SPEC_FIELD_NUMBER: builtins.int
    @property
    def metadata(self) -> global___K8sObjectMetadata:
        """Contains additional metadata for building a kubernetes pod."""
        pass
    @property
    def pod_spec(self) -> google.protobuf.struct_pb2.Struct:
        """Defines the primary pod spec created when a task is executed.
        This should be a JSON-marshalled pod spec, which can be defined in 
        - go, using: https://github.com/kubernetes/api/blob/release-1.21/core/v1/types.go#L2936
        - python: using https://github.com/kubernetes-client/python/blob/release-19.0/kubernetes/client/models/v1_pod_spec.py
        """
        pass
    def __init__(self,
        *,
        metadata : typing.Optional[global___K8sObjectMetadata] = ...,
        pod_spec : typing.Optional[google.protobuf.struct_pb2.Struct] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"metadata",b"metadata",u"pod_spec",b"pod_spec"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"metadata",b"metadata",u"pod_spec",b"pod_spec"]) -> None: ...
global___K8sPod = K8sPod

class K8sObjectMetadata(google.protobuf.message.Message):
    """Metadata for building a kubernetes object when a task is executed."""
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class LabelsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    class AnnotationsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: typing.Text = ...
        value: typing.Text = ...
        def __init__(self,
            *,
            key : typing.Text = ...,
            value : typing.Text = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"value",b"value"]) -> None: ...

    LABELS_FIELD_NUMBER: builtins.int
    ANNOTATIONS_FIELD_NUMBER: builtins.int
    @property
    def labels(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Optional labels to add to the pod definition."""
        pass
    @property
    def annotations(self) -> google.protobuf.internal.containers.ScalarMap[typing.Text, typing.Text]:
        """Optional annotations to add to the pod definition."""
        pass
    def __init__(self,
        *,
        labels : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        annotations : typing.Optional[typing.Mapping[typing.Text, typing.Text]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"annotations",b"annotations",u"labels",b"labels"]) -> None: ...
global___K8sObjectMetadata = K8sObjectMetadata
