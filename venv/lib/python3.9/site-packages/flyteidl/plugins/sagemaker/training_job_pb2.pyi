"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class InputMode(google.protobuf.message.Message):
    """The input mode that the algorithm supports. When using the File input mode, SageMaker downloads
    the training data from S3 to the provisioned ML storage Volume, and mounts the directory to docker
    volume for training container. When using Pipe input mode, Amazon SageMaker streams data directly
    from S3 to the container.
    See: https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_AlgorithmSpecification.html
    For the input modes that different SageMaker algorithms support, see:
    https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Value(_Value, metaclass=_ValueEnumTypeWrapper):
        pass
    class _Value:
        V = typing.NewType('V', builtins.int)
    class _ValueEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Value.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        FILE = InputMode.Value.V(0)
        PIPE = InputMode.Value.V(1)

    FILE = InputMode.Value.V(0)
    PIPE = InputMode.Value.V(1)

    def __init__(self,
        ) -> None: ...
global___InputMode = InputMode

class AlgorithmName(google.protobuf.message.Message):
    """The algorithm name is used for deciding which pre-built image to point to.
    This is only required for use cases where SageMaker's built-in algorithm mode is used.
    While we currently only support a subset of the algorithms, more will be added to the list.
    See: https://docs.aws.amazon.com/sagemaker/latest/dg/algos.html
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Value(_Value, metaclass=_ValueEnumTypeWrapper):
        pass
    class _Value:
        V = typing.NewType('V', builtins.int)
    class _ValueEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Value.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        CUSTOM = AlgorithmName.Value.V(0)
        XGBOOST = AlgorithmName.Value.V(1)

    CUSTOM = AlgorithmName.Value.V(0)
    XGBOOST = AlgorithmName.Value.V(1)

    def __init__(self,
        ) -> None: ...
global___AlgorithmName = AlgorithmName

class InputContentType(google.protobuf.message.Message):
    """Specifies the type of file for input data. Different SageMaker built-in algorithms require different file types of input data
    See https://docs.aws.amazon.com/sagemaker/latest/dg/cdf-training.html
    https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Value(_Value, metaclass=_ValueEnumTypeWrapper):
        pass
    class _Value:
        V = typing.NewType('V', builtins.int)
    class _ValueEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Value.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        TEXT_CSV = InputContentType.Value.V(0)

    TEXT_CSV = InputContentType.Value.V(0)

    def __init__(self,
        ) -> None: ...
global___InputContentType = InputContentType

class MetricDefinition(google.protobuf.message.Message):
    """Specifies a metric that the training algorithm writes to stderr or stdout.
    This object is a pass-through.
    See this for details: https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_MetricDefinition.html
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    NAME_FIELD_NUMBER: builtins.int
    REGEX_FIELD_NUMBER: builtins.int
    name: typing.Text = ...
    """User-defined name of the metric"""

    regex: typing.Text = ...
    """SageMaker hyperparameter tuning parses your algorithmâ€™s stdout and stderr streams to find algorithm metrics"""

    def __init__(self,
        *,
        name : typing.Text = ...,
        regex : typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"name",b"name",u"regex",b"regex"]) -> None: ...
global___MetricDefinition = MetricDefinition

class AlgorithmSpecification(google.protobuf.message.Message):
    """Specifies the training algorithm to be used in the training job
    This object is mostly a pass-through, with a couple of exceptions include: (1) in Flyte, users don't need to specify
    TrainingImage; either use the built-in algorithm mode by using Flytekit's Simple Training Job and specifying an algorithm
    name and an algorithm version or (2) when users want to supply custom algorithms they should set algorithm_name field to
    CUSTOM. In this case, the value of the algorithm_version field has no effect
    For pass-through use cases: refer to this AWS official document for more details
    https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_AlgorithmSpecification.html
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INPUT_MODE_FIELD_NUMBER: builtins.int
    ALGORITHM_NAME_FIELD_NUMBER: builtins.int
    ALGORITHM_VERSION_FIELD_NUMBER: builtins.int
    METRIC_DEFINITIONS_FIELD_NUMBER: builtins.int
    INPUT_CONTENT_TYPE_FIELD_NUMBER: builtins.int
    input_mode: global___InputMode.Value.V = ...
    """The input mode can be either PIPE or FILE"""

    algorithm_name: global___AlgorithmName.Value.V = ...
    """The algorithm name is used for deciding which pre-built image to point to"""

    algorithm_version: typing.Text = ...
    """The algorithm version field is used for deciding which pre-built image to point to
    This is only needed for use cases where SageMaker's built-in algorithm mode is chosen
    """

    @property
    def metric_definitions(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MetricDefinition]:
        """A list of metric definitions for SageMaker to evaluate/track on the progress of the training job
        See this: https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_AlgorithmSpecification.html
        and this: https://docs.aws.amazon.com/sagemaker/latest/dg/automatic-model-tuning-define-metrics.html
        """
        pass
    input_content_type: global___InputContentType.Value.V = ...
    """The content type of the input
    See https://docs.aws.amazon.com/sagemaker/latest/dg/cdf-training.html
    https://docs.aws.amazon.com/sagemaker/latest/dg/sagemaker-algo-docker-registry-paths.html
    """

    def __init__(self,
        *,
        input_mode : global___InputMode.Value.V = ...,
        algorithm_name : global___AlgorithmName.Value.V = ...,
        algorithm_version : typing.Text = ...,
        metric_definitions : typing.Optional[typing.Iterable[global___MetricDefinition]] = ...,
        input_content_type : global___InputContentType.Value.V = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"algorithm_name",b"algorithm_name",u"algorithm_version",b"algorithm_version",u"input_content_type",b"input_content_type",u"input_mode",b"input_mode",u"metric_definitions",b"metric_definitions"]) -> None: ...
global___AlgorithmSpecification = AlgorithmSpecification

class DistributedProtocol(google.protobuf.message.Message):
    """When enabling distributed training on a training job, the user should use this message to tell Flyte and SageMaker
    what kind of distributed protocol he/she wants to use to distribute the work.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    class Value(_Value, metaclass=_ValueEnumTypeWrapper):
        pass
    class _Value:
        V = typing.NewType('V', builtins.int)
    class _ValueEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_Value.V], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
        UNSPECIFIED = DistributedProtocol.Value.V(0)
        """Use this value if the user wishes to use framework-native distributed training interfaces.
        If this value is used, Flyte won't configure SageMaker to initialize unnecessary components such as
        OpenMPI or Parameter Server.
        """

        MPI = DistributedProtocol.Value.V(1)
        """Use this value if the user wishes to use MPI as the underlying protocol for her distributed training job
        MPI is a framework-agnostic distributed protocol. It has multiple implementations. Currently, we have only
        tested the OpenMPI implementation, which is the recommended implementation for Horovod.
        """


    UNSPECIFIED = DistributedProtocol.Value.V(0)
    """Use this value if the user wishes to use framework-native distributed training interfaces.
    If this value is used, Flyte won't configure SageMaker to initialize unnecessary components such as
    OpenMPI or Parameter Server.
    """

    MPI = DistributedProtocol.Value.V(1)
    """Use this value if the user wishes to use MPI as the underlying protocol for her distributed training job
    MPI is a framework-agnostic distributed protocol. It has multiple implementations. Currently, we have only
    tested the OpenMPI implementation, which is the recommended implementation for Horovod.
    """


    def __init__(self,
        ) -> None: ...
global___DistributedProtocol = DistributedProtocol

class TrainingJobResourceConfig(google.protobuf.message.Message):
    """TrainingJobResourceConfig is a pass-through, specifying the instance type to use for the training job, the
    number of instances to launch, and the size of the ML storage volume the user wants to provision
    Refer to SageMaker official doc for more details: https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateTrainingJob.html
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    INSTANCE_COUNT_FIELD_NUMBER: builtins.int
    INSTANCE_TYPE_FIELD_NUMBER: builtins.int
    VOLUME_SIZE_IN_GB_FIELD_NUMBER: builtins.int
    DISTRIBUTED_PROTOCOL_FIELD_NUMBER: builtins.int
    instance_count: builtins.int = ...
    """The number of ML compute instances to use. For distributed training, provide a value greater than 1."""

    instance_type: typing.Text = ...
    """The ML compute instance type"""

    volume_size_in_gb: builtins.int = ...
    """The size of the ML storage volume that you want to provision."""

    distributed_protocol: global___DistributedProtocol.Value.V = ...
    """When users specify an instance_count > 1, Flyte will try to configure SageMaker to enable distributed training.
    If the users wish to use framework-agnostic distributed protocol such as MPI or Parameter Server, this
    field should be set to the corresponding enum value
    """

    def __init__(self,
        *,
        instance_count : builtins.int = ...,
        instance_type : typing.Text = ...,
        volume_size_in_gb : builtins.int = ...,
        distributed_protocol : global___DistributedProtocol.Value.V = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"distributed_protocol",b"distributed_protocol",u"instance_count",b"instance_count",u"instance_type",b"instance_type",u"volume_size_in_gb",b"volume_size_in_gb"]) -> None: ...
global___TrainingJobResourceConfig = TrainingJobResourceConfig

class TrainingJob(google.protobuf.message.Message):
    """The spec of a training job. This is mostly a pass-through object
    https://docs.aws.amazon.com/sagemaker/latest/APIReference/API_CreateTrainingJob.html
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ALGORITHM_SPECIFICATION_FIELD_NUMBER: builtins.int
    TRAINING_JOB_RESOURCE_CONFIG_FIELD_NUMBER: builtins.int
    @property
    def algorithm_specification(self) -> global___AlgorithmSpecification: ...
    @property
    def training_job_resource_config(self) -> global___TrainingJobResourceConfig: ...
    def __init__(self,
        *,
        algorithm_specification : typing.Optional[global___AlgorithmSpecification] = ...,
        training_job_resource_config : typing.Optional[global___TrainingJobResourceConfig] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"algorithm_specification",b"algorithm_specification",u"training_job_resource_config",b"training_job_resource_config"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"algorithm_specification",b"algorithm_specification",u"training_job_resource_config",b"training_job_resource_config"]) -> None: ...
global___TrainingJob = TrainingJob
